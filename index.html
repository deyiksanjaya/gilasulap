<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generator Roda Warna</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Menggunakan font Inter dari Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        /* Variabel CSS untuk tema warna */
        :root {
            --bg-dark: #0f172a;
            --bg-light: #1e2b3b;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --pointer-color: #f43f5e;
        }

        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: var(--bg-dark);
            color: var(--text-primary);
        }

        /* Kontainer utama untuk layout yang lebih baik */
        #app-container {
            width: 100%;
            max-width: 480px; /* Lebar maksimal untuk tampilan desktop */
        }

        canvas {
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            filter: drop-shadow(0 10px 15px rgba(0, 0, 0, 0.3));
        }
        canvas:active {
            transform: scale(0.97);
        }

        /* Indikator titik yang tidak menggeser layout */
        #instructions.indicator-active::after {
            content: '.';
            position: absolute;
        }

        /* Penunjuk roda yang didesain ulang */
        #pointer {
            width: 0;
            height: 0;
            border-left: 16px solid transparent;
            border-right: 16px solid transparent;
            border-top: 28px solid var(--pointer-color);
            filter: drop-shadow(0 4px 8px rgba(244, 63, 94, 0.5));
            margin-bottom: -14px;
            z-index: 10;
        }

        /* Kotak hasil dengan efek frosted glass */
        #resultBox {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <!-- Kontainer utama aplikasi -->
    <main id="app-container" class="text-center flex flex-col items-center">
        
        <h1 class="text-3xl sm:text-4xl font-bold text-slate-100 mb-3">Generator Roda Warna</h1>
        <p id="instructions" class="text-slate-400 mb-8 max-w-sm mx-auto relative">Klik roda untuk memutar dan menghasilkan warna baru</p>
        
        <!-- Kontainer untuk roda dan penunjuknya -->
        <div id="wheel-wrapper" class="relative flex flex-col items-center">
            <div id="pointer"></div>
            <canvas id="colorWheel"></canvas>
        </div>

        <!-- Kontainer hasil untuk mencegah layout shift -->
        <div id="result-container" class="mt-8 w-full min-h-[8rem]">
            <div id="resultBox" class="p-4 rounded-xl w-full h-full flex items-center">
                <div class="w-28 flex-shrink-0 text-center pr-4 border-r border-slate-600/50">
                    <p id="resultName" class="text-2xl font-bold tracking-wider break-words">---</p>
                </div>
                <div class="flex-grow text-left pl-4">
                    <p id="resultDescription" class="text-slate-400 text-sm leading-relaxed">Putar roda untuk melihat deskripsi warna di sini.</p>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Inisialisasi elemen DOM
        const canvas = document.getElementById('colorWheel');
        const ctx = canvas.getContext('2d');
        const resultBox = document.getElementById('resultBox');
        const resultName = document.getElementById('resultName');
        const resultDescription = document.getElementById('resultDescription');
        const instructions = document.getElementById('instructions');
        const body = document.body;

        // Konfigurasi Roda
        const segments = [
            { color: '#e74c3c', name: 'Merah', description: 'Kuat dan mendominasi. Efektif untuk call-to-action (CTA), notifikasi error, dan elemen yang butuh perhatian segera.' },
            { color: '#e67e22', name: 'Oranye', description: 'Enerjik dan ramah. Baik untuk tombol konfirmasi atau area yang menonjolkan kreativitas dan antusiasme.' },
            { color: '#f1c40f', name: 'Kuning', description: 'Menarik perhatian tanpa agresif. Digunakan untuk highlight, pesan peringatan ringan, atau nuansa optimis.' },
            { color: '#a6e22e', name: 'Lime', description: 'Segar, modern, dan bersemangat. Sering diasosiasikan dengan alam, kesehatan, dan industri teknologi.' },
            { color: '#2ecc71', name: 'Hijau', description: 'Menandakan pertumbuhan dan kesuksesan. Umumnya dipakai untuk notifikasi berhasil, validasi, dan tema finansial.' },
            { color: '#1abc9c', name: 'Tosca', description: 'Menyeimbangkan ketenangan biru dan energi hijau. Populer untuk UI yang bersih, modern, dan menyegarkan.' },
            { color: '#81d4fa', name: 'Biru Langit', description: 'Menciptakan rasa tenang dan terbuka. Cocok untuk latar belakang atau elemen yang ingin memberi kesan lapang.' },
            { color: '#3498db', name: 'Biru', description: 'Membangun kepercayaan dan profesionalisme. Pilihan utama untuk aplikasi korporat, perbankan, dan teknologi.' },
            { color: '#9b59b6', name: 'Ungu', description: 'Identik dengan kemewahan, kebijaksanaan, dan kreativitas. Efektif untuk produk atau layanan premium.' },
            { color: '#fd5ff1', name: 'Magenta', description: 'Berani, artistik, dan non-konvensional. Pilihan tepat untuk membuat pernyataan visual yang kuat.' },
            { color: '#ff79c6', name: 'Pink', description: 'Menargetkan demografi yang lebih muda dengan nuansa yang menyenangkan, manis, dan energik.' },
            { color: '#ecf0f1', name: 'Putih', description: 'Fundamental untuk minimalisme. Digunakan sebagai ruang negatif untuk meningkatkan keterbacaan dan fokus.' }
        ];

        const numSegments = segments.length;
        const sliceAngle = (2 * Math.PI) / numSegments;
        
        // Penskalaan DPI untuk Canvas Tajam
        const baseSize = 300;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = baseSize * dpr;
        canvas.height = baseSize * dpr;
        canvas.style.width = `${baseSize}px`;
        canvas.style.height = `${baseSize}px`;
        ctx.scale(dpr, dpr);
        const radius = baseSize / 2;

        // Variabel Status
        let currentAngle = 0;
        let isAnimating = false;
        let forceModeActive = false;
        let longPressTimer;
        const longPressDuration = 700;
        let availableColors = [];

        // --- Fungsi Utilitas ---
        const resetAvailableColors = () => {
            // Hanya Merah (indeks 0) yang dikecualikan dari putaran acak biasa
            availableColors = segments
                .map((_, index) => index)
                .filter(index => index !== 0);
        };

        const hexToGrayscale = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const grayValue = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            const grayHex = grayValue.toString(16).padStart(2, '0');
            return `#${grayHex}${grayHex}${grayHex}`;
        };

        const interpolateColor = (color1, color2, factor) => {
            const r1 = parseInt(color1.slice(1, 3), 16), g1 = parseInt(color1.slice(3, 5), 16), b1 = parseInt(color1.slice(5, 7), 16);
            const r2 = parseInt(color2.slice(1, 3), 16), g2 = parseInt(color2.slice(3, 5), 16), b2 = parseInt(color2.slice(5, 7), 16);
            const r = Math.round(r1 + factor * (r2 - r1)), g = Math.round(g1 + factor * (g2 - g1)), b = Math.round(b1 + factor * (b2 - b1));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        };

        // --- Fungsi Menggambar ---
        const drawWheel = (highlightedIndex = null, fadeProgress = 0) => {
            ctx.clearRect(0, 0, baseSize, baseSize);
            ctx.save();
            ctx.translate(radius, radius);
            ctx.rotate(currentAngle);

            segments.forEach((segment, i) => {
                const isHighlighted = highlightedIndex !== null && i === highlightedIndex;
                const targetColor = isHighlighted ? segment.color : hexToGrayscale(segment.color);
                const fillColor = highlightedIndex !== null ? interpolateColor(segment.color, targetColor, fadeProgress) : segment.color;
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radius - 5, -sliceAngle / 2, sliceAngle / 2, false);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.rotate(sliceAngle);
            });
            
            ctx.rotate(-sliceAngle / 2);
            ctx.strokeStyle = 'rgba(15, 23, 42, 0.7)';
            ctx.lineWidth = 2;
            segments.forEach(() => {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(radius - 5, 0);
                ctx.stroke();
                ctx.rotate(sliceAngle);
            });
            ctx.restore();

            ctx.save();
            ctx.translate(radius, radius);
            const hubGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 25);
            hubGradient.addColorStop(0, '#cbd5e1');
            hubGradient.addColorStop(1, '#64748b');
            ctx.fillStyle = hubGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
        };

        // --- Fungsi Animasi ---
        const spinWheel = () => {
            if (isAnimating) return;
            isAnimating = true;
            animateHighlight(null, true);

            const spinDuration = 5000;
            const randomSpins = Math.floor(Math.random() * 5) + 8;
            let targetSegment;

            if (forceModeActive) {
                targetSegment = 0; // Paksa berhenti di Merah (indeks 0)
                forceModeActive = false;
                instructions.classList.remove('indicator-active'); 
            } else {
                if (availableColors.length === 0) resetAvailableColors();
                const randomIndex = Math.floor(Math.random() * availableColors.length);
                targetSegment = availableColors.splice(randomIndex, 1)[0];
            }
            
            const targetRotation = targetSegment * sliceAngle;
            const stopAngle = (1.5 * Math.PI) - targetRotation;
            const finalAngle = (randomSpins * 2 * Math.PI) + stopAngle;

            let startTime = null;
            const animateSpin = (timestamp) => {
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;
                if (elapsedTime < spinDuration) {
                    const progress = elapsedTime / spinDuration;
                    const easeOutProgress = 1 - Math.pow(1 - progress, 4);
                    currentAngle = easeOutProgress * finalAngle;
                    drawWheel();
                    requestAnimationFrame(animateSpin);
                } else {
                    currentAngle = finalAngle;
                    isAnimating = false;
                    showResult(targetSegment);
                }
            };
            requestAnimationFrame(animateSpin);
        };

        const showResult = (winningSegmentIndex, withAnimation = true) => {
            const winner = segments[winningSegmentIndex];
            resultName.textContent = winner.name;
            resultName.style.color = winner.color;
            resultDescription.textContent = winner.description;

            if (withAnimation) {
                animateHighlight(winningSegmentIndex, false, () => {
                    setTimeout(() => {
                        if (!isAnimating) animateHighlight(winningSegmentIndex, true);
                    }, 2500);
                });
            }
        };
        
        const animateHighlight = (highlightedIndex, reverse = false, onComplete = () => {}) => {
            const fadeDuration = 500;
            let startTime = null;
            const animationStep = (timestamp) => {
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;
                let progress = Math.min(elapsedTime / fadeDuration, 1);
                const fadeProgress = reverse ? 1 - progress : progress;
                drawWheel(highlightedIndex, fadeProgress);
                if (progress < 1) {
                    requestAnimationFrame(animationStep);
                } else {
                    onComplete();
                }
            };
            requestAnimationFrame(animationStep);
        };

        // --- Event Listeners ---
        canvas.addEventListener('click', spinWheel);

        const handlePressStart = (e) => {
            if (e.target !== canvas && !isAnimating) {
                longPressTimer = setTimeout(() => {
                    forceModeActive = true;
                    instructions.classList.add('indicator-active');
                }, longPressDuration);
            }
        };
        const handlePressEnd = () => clearTimeout(longPressTimer);

        body.addEventListener('mousedown', handlePressStart);
        body.addEventListener('mouseup', handlePressEnd);
        body.addEventListener('mouseleave', handlePressEnd);
        body.addEventListener('touchstart', handlePressStart);
        body.addEventListener('touchend', handlePressEnd);
        // PERBAIKAN: Tambahkan event listener untuk touchmove
        body.addEventListener('touchmove', handlePressEnd);

        // Inisialisasi Aplikasi
        resetAvailableColors();
        // Hapus Magenta (indeks 9) dari siklus acak pertama
        const initialMagentaIndexInAvailable = availableColors.indexOf(9);
        if (initialMagentaIndexInAvailable > -1) {
            availableColors.splice(initialMagentaIndexInAvailable, 1);
        }
        drawWheel();
        showResult(9, false); // Menampilkan Magenta (indeks 9) saat halaman dimuat
    </script>

</body>
</html>

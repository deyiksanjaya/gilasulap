<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generator Warna Acak</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Menggunakan font Inter dari Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Mencegah zoom saat disentuh di mobile */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
            /* Latar belakang gradien premium */
            background-color: #0f172a;
            background-image: radial-gradient(ellipse at center, #1e2b3b 0%, #0f172a 100%);
        }
        canvas {
            cursor: pointer;
            transition: transform 0.2s ease;
            filter: drop-shadow(0 10px 15px rgba(0, 0, 0, 0.3));
        }
        canvas:active {
            transform: scale(0.98);
        }
        /* Style baru untuk indikator titik agar tidak menggeser teks */
        #instructions.indicator-active::after {
            content: '.';
            position: absolute;
        }
        /* Style baru untuk judul */
        h1 {
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        /* Style baru untuk penunjuk roda */
        #pointer {
            width: 30px;
            height: 40px;
            background: linear-gradient(180deg, #f87171, #ef4444);
            clip-path: polygon(50% 100%, 0 0, 100% 0);
            border-radius: 5px;
            box-shadow: 0 5px 10px rgba(239, 68, 68, 0.4);
            margin-bottom: -20px;
            z-index: 10;
        }
        /* Style baru untuk kotak hasil */
        #resultBox {
            background: rgba(30, 41, 59, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen overflow-hidden p-4">

    <!-- Kontainer utama -->
    <div class="text-center flex flex-col items-center">
        <h1 class="text-3xl md:text-4xl font-bold mb-4 text-slate-200">Generator Roda Warna</h1>
        <p id="instructions" class="text-slate-400 mb-8 max-w-md mx-auto relative">Klik roda untuk memutar dan menghasilkan warna baru</p>
        
        <!-- Penunjuk statis untuk roda (didesain ulang) -->
        <div id="pointer"></div>

        <!-- Roda Warna menggunakan Canvas (width dan height dihapus dari HTML) -->
        <canvas id="colorWheel"></canvas>

        <!-- Kotak untuk menampilkan hasil warna (DIPERBAIKI: Layout Horizontal) -->
        <div id="resultBox" class="mt-8 p-4 rounded-xl w-full max-w-md invisible opacity-0 transition-opacity duration-500 flex items-center h-28">
            <div class="w-1/3 flex-shrink-0 text-center pr-4 border-r border-slate-600">
                <p id="resultName" class="text-2xl font-bold tracking-wider"></p>
            </div>
            <div class="w-2/3 text-left pl-4">
                <p id="resultDescription" class="text-slate-300 text-sm leading-relaxed"></p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('colorWheel');
        const ctx = canvas.getContext('2d');
        const resultBox = document.getElementById('resultBox');
        const resultName = document.getElementById('resultName');
        const resultDescription = document.getElementById('resultDescription');
        const instructions = document.getElementById('instructions');
        const body = document.body;

        // Daftar warna untuk segmen roda (DESKRIPSI DIPERBARUI)
        const segments = [
            { color: '#e74c3c', name: 'Merah', description: 'Kuat dan mendominasi. Efektif untuk call-to-action (CTA), notifikasi error, dan elemen yang butuh perhatian segera.' },
            { color: '#e67e22', name: 'Oranye', description: 'Enerjik dan ramah. Baik untuk tombol konfirmasi atau area yang menonjolkan kreativitas dan antusiasme.' },
            { color: '#f1c40f', name: 'Kuning', description: 'Menarik perhatian tanpa agresif. Digunakan untuk highlight, pesan peringatan ringan, atau nuansa optimis.' },
            { color: '#a6e22e', name: 'Lime', description: 'Segar, modern, dan bersemangat. Sering diasosiasikan dengan alam, kesehatan, dan industri teknologi.' },
            { color: '#2ecc71', name: 'Hijau', description: 'Menandakan pertumbuhan dan kesuksesan. Umumnya dipakai untuk notifikasi berhasil, validasi, dan tema finansial.' },
            { color: '#1abc9c', name: 'Tosca', description: 'Menyeimbangkan ketenangan biru dan energi hijau. Populer untuk UI yang bersih, modern, dan menyegarkan.' },
            { color: '#81d4fa', name: 'Biru Langit', description: 'Menciptakan rasa tenang dan terbuka. Cocok untuk latar belakang atau elemen yang ingin memberi kesan lapang.' },
            { color: '#3498db', name: 'Biru', description: 'Membangun kepercayaan dan profesionalisme. Pilihan utama untuk aplikasi korporat, perbankan, dan teknologi.' },
            { color: '#9b59b6', name: 'Ungu', description: 'Identik dengan kemewahan, kebijaksanaan, dan kreativitas. Efektif untuk produk atau layanan premium.' },
            { color: '#fd5ff1', name: 'Magenta', description: 'Berani, artistik, dan non-konvensional. Pilihan tepat untuk membuat pernyataan visual yang kuat.' },
            { color: '#ff79c6', name: 'Pink', description: 'Menargetkan demografi yang lebih muda dengan nuansa yang menyenangkan, manis, dan energik.' },
            { color: '#ecf0f1', name: 'Putih', description: 'Fundamental untuk minimalisme. Digunakan sebagai ruang negatif untuk meningkatkan keterbacaan dan fokus.' }
        ];

        const numSegments = segments.length;
        const sliceAngle = (2 * Math.PI) / numSegments;
        
        // --- PERBAIKAN: Logika Penskalaan DPI untuk Canvas Tajam ---
        const baseSize = 320; // Ukuran dasar canvas
        const dpr = window.devicePixelRatio || 1; // Mendapatkan rasio piksel perangkat
        canvas.width = baseSize * dpr; // Mengatur ukuran buffer gambar internal
        canvas.height = baseSize * dpr;
        canvas.style.width = `${baseSize}px`; // Mengatur ukuran tampilan di layar
        canvas.style.height = `${baseSize}px`;
        ctx.scale(dpr, dpr); // Menskalakan konteks gambar
        const radius = baseSize / 2; // Radius sekarang dihitung dari ukuran dasar
        // --- Akhir Perbaikan ---

        let currentAngle = 0;
        let isAnimating = false;
        let forceModeActive = false;
        let longPressTimer;
        const longPressDuration = 700;
        let availableColors = [];

        function resetAvailableColors() {
            availableColors = segments.slice(1).map((_, index) => index + 1);
        }

        function hexToGrayscale(hex) {
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            const grayValue = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            const grayHex = grayValue.toString(16).padStart(2, '0');
            return `#${grayHex}${grayHex}${grayHex}`;
        }

        function interpolateColor(color1, color2, factor) {
            const r1 = parseInt(color1.substring(1, 3), 16), g1 = parseInt(color1.substring(3, 5), 16), b1 = parseInt(color1.substring(5, 7), 16);
            const r2 = parseInt(color2.substring(1, 3), 16), g2 = parseInt(color2.substring(3, 5), 16), b2 = parseInt(color2.substring(5, 7), 16);
            const r = Math.round(r1 + factor * (r2 - r1)), g = Math.round(g1 + factor * (g2 - g1)), b = Math.round(b1 + factor * (b2 - b1));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function drawWheel(highlightedIndex = null, fadeProgress = 0) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(radius, radius);
            ctx.rotate(currentAngle);

            segments.forEach((segment, i) => {
                const isHighlighted = highlightedIndex !== null && i === highlightedIndex;
                const targetColor = isHighlighted ? segment.color : hexToGrayscale(segment.color);
                const startColor = segment.color;
                const fillColor = highlightedIndex !== null ? interpolateColor(startColor, targetColor, fadeProgress) : startColor;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radius - 5, -sliceAngle / 2, sliceAngle / 2, false);
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.rotate(sliceAngle);
            });
            
            ctx.rotate(-sliceAngle / 2);
            ctx.strokeStyle = 'rgba(15, 23, 42, 0.5)';
            ctx.lineWidth = 3;
            segments.forEach(() => {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(radius - 5, 0);
                ctx.stroke();
                ctx.rotate(sliceAngle);
            });
            ctx.restore();

            ctx.save();
            ctx.translate(radius, radius);
            const hubGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 25);
            hubGradient.addColorStop(0, '#cbd5e1');
            hubGradient.addColorStop(1, '#64748b');
            ctx.fillStyle = hubGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        function spinWheel() {
            if (isAnimating) return;
            isAnimating = true;
            resultBox.classList.add('opacity-0', 'invisible');
            animateHighlight(null, true);

            const spinDuration = 5000;
            const randomSpins = Math.floor(Math.random() * 5) + 8;
            let targetSegment;

            if (forceModeActive) {
                targetSegment = 0;
                forceModeActive = false;
                instructions.classList.remove('indicator-active'); 
            } else {
                if (availableColors.length === 0) resetAvailableColors();
                const randomIndex = Math.floor(Math.random() * availableColors.length);
                targetSegment = availableColors.splice(randomIndex, 1)[0];
            }
            
            const targetRotation = targetSegment * sliceAngle;
            const stopAngle = (1.5 * Math.PI) - targetRotation;
            const finalAngle = (randomSpins * 2 * Math.PI) + stopAngle;

            let startTime = null;
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;
                if (elapsedTime < spinDuration) {
                    const progress = elapsedTime / spinDuration;
                    const easeOutProgress = 1 - Math.pow(1 - progress, 4);
                    currentAngle = easeOutProgress * finalAngle;
                    drawWheel();
                    requestAnimationFrame(animate);
                } else {
                    currentAngle = finalAngle;
                    isAnimating = false;
                    showResult(targetSegment);
                }
            }
            requestAnimationFrame(animate);
        }

        function showResult(winningSegmentIndex) {
            const winner = segments[winningSegmentIndex];
            resultName.textContent = winner.name;
            resultName.style.color = winner.color;
            resultDescription.textContent = winner.description;
            resultBox.classList.remove('opacity-0', 'invisible');

            animateHighlight(winningSegmentIndex, false, () => {
                setTimeout(() => {
                    if (!isAnimating) {
                       animateHighlight(winningSegmentIndex, true);
                    }
                }, 2000);
            });
        }
        
        function animateHighlight(highlightedIndex, reverse = false, onComplete = () => {}) {
            const fadeDuration = 500;
            let startTime = null;
            function animationStep(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;
                let progress = elapsedTime / fadeDuration;
                if (progress > 1) progress = 1;
                const fadeProgress = reverse ? 1 - progress : progress;
                drawWheel(highlightedIndex, fadeProgress);
                if (progress < 1) {
                    requestAnimationFrame(animationStep);
                } else {
                    onComplete();
                }
            }
            requestAnimationFrame(animationStep);
        }

        canvas.addEventListener('click', spinWheel);

        function handlePressStart(e) {
            if (e.target !== canvas && !isAnimating) {
                longPressTimer = setTimeout(() => {
                    forceModeActive = true;
                    instructions.classList.add('indicator-active');
                }, longPressDuration);
            }
        }

        function handlePressEnd() { clearTimeout(longPressTimer); }

        body.addEventListener('mousedown', handlePressStart);
        body.addEventListener('mouseup', handlePressEnd);
        body.addEventListener('mouseleave', handlePressEnd);
        body.addEventListener('touchstart', handlePressStart);
        body.addEventListener('touchend', handlePressEnd);

        resetAvailableColors();
        drawWheel();
    </script>

</body>
</html>
